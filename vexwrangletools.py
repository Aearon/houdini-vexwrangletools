import re
import hou

def literalsToParms(nodes):
    """For each node in nodes that has a snippet parameter (e.g. all the wrangle
    sops):
    
    Adds a parameter for each variable declared in the code, if that variable
    is just assigned a literal. The declaration itself is changed so it
    references the created parameter.

    e.g. if somewhere in your snippet, you have the line
    
    vector normal = {1,2,3};

    a float parameter named 'normal' with 3 components will be created on the
    node, with it's default set to 1,2,3. The line in the code will be changed
    to:
    
    vector normal = ch("normal");

    If the method is run on a node that already has these auto-generated 
    parameters, it'll updated them:
    
    * change the parameter type if the variable's type has changed in the code
    * change the number of components if it has changed in the code
    * delete parameters who's corresponding declaration has been removed
    * update default values

    The parameters are created at the top of the parameter interface,
    with a separator below. The separator is called 'auto_generated'. All
    parameters above this separator are considered to have been generated by
    this script and are fair game for deletion when running the script again.
    """
    for node in nodes:
        snippet_parm = node.parm('snippet')

        if not snippet_parm:
            continue

        snippet = snippet_parm.eval()

        vex_lines = snippet.strip().split("\n")

        declarations = _findDeclarations(vex_lines)
        parm_type = None

        tempGroup = node.parmTemplateGroup()

        sep = tempGroup.find('auto_generated')
        
        if not sep:
            sep = hou.SeparatorParmTemplate('auto_generated')

            tempGroup.insertBefore(tempGroup.entries()[0], sep)
        
        
        if declarations:
            varnames = zip(*declarations)[2]
        else:
            varnames = []

        # delete parameters that are above the auto_generated separator, and not in the list of declared variables
        for entry in tempGroup.entries():
            if entry.name() == 'auto_generated':
                break
            elif entry.name() not in varnames:
                tempGroup.remove(entry)

        for decl in declarations:
            linenum, vartype, varname, varvalue = decl
            if not varvalue:
                continue
            
            template = None
            numComps = None
            function = None

            if vartype == 'float':
                template = hou.FloatParmTemplate(varname, varname, 1)
                parm_type = template.type()
                numComps = 1
                function = 'chf'
            if vartype == 'int':
                template = hou.IntParmTemplate(varname, varname, 1)
                parm_type = template.type()
                numComps = 1
                function = 'ch'
            elif vartype == 'vector':
                template = hou.FloatParmTemplate(varname, varname, 3)
                parm_type = template.type()
                numComps = 3
                function = 'chv'
            elif vartype == 'vector4':
                template = hou.FloatParmTemplate(varname, varname, 4)
                parm_type = template.type()
                numComps = 4
                function = 'chv'
            elif vartype == 'string':
                template = hou.StringParmTemplate(varname, varname, 1)
                parm_type = template.type()
                numComps = 1
                function = 'chs'

            if parm_type == hou.parmTemplateType.Float:
                valtype = float
            else:
                valtype = int
                
            print decl
            
            if vartype == 'string':
                varvalue = [varvalue[1:-1]] # strip quotes, wrap in list
            else:
                g = re.match(r"[\{\s]*([0-9\.\ f\,]*).*", varvalue).groups()[0]
                varvalue  = [valtype(comp) for comp in g.split(',')]
            
            if template:
                existing_template = tempGroup.find(varname)
                
                if not existing_template:
                    pass
                elif existing_template.type() != parm_type:
                    existing_template = None
                    tempGroup.remove(varname)
                elif existing_template.numComponents() != numComps:
                    existing_template = None
                    tempGroup.remove(varname)
                else:
                    template = existing_template

                template.setNumComponents(numComps)

                template.setDefaultValue(varvalue)

                if not existing_template:
                    tempGroup.insertBefore(sep, template)
                if template == existing_template:
                    tempGroup.replace(varname, template)
                
                vex_lines[linenum] = "%s %s = %s(\"%s\");" % (vartype, varname, function, varname)

        node.setParmTemplateGroup(tempGroup)
        new_code = "\n".join(vex_lines)
        snippet_parm.set(new_code)


def _findDeclarations(vex_code_lines):
    decl = []
    
    # find simple assignments
    for i, line in enumerate(vex_code_lines):
        # match word word = number or {number, number, ...}
        m = re.match(r"([@\w]+) ([@\w]+) *\= *((?:{.*}|\".*\"|[0-9\.]*))", line)
        
        if not m: continue
        
        vartype, varname, value = m.groups()
        
        #if not value: continue
        
        decl.append((i, vartype, varname, value))
    
    return decl

